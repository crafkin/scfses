/************************************************************************************************************/
/* This dofile generates percentiles and standard errors for the SCF                                        */
/* The basic idea is that an unbiased estimator for the percentile of interest is the mean of               */
/* each of the five percentiles within implicate                                                            */
/*                                                                                                          */
/* Then the variance is the (implicate-weighted) combination of the                                         */
/* variation between implicates and the within-implicate variance given by the weighted bootstrap, given by */
/* V = (m+1) / m * (implicate-variance) + (replicate variance)                                              */
/*                                                                                                          */
/* Then, we also report the degree of freedom for the T-test, following Barnard and Rubin (1999).           */
/* Last edited: December, 2017                                                                              */
/************************************************************************************************************/  
capture pr drop scfses 
pr define scfses, eclass 
syntax varlist [if] [pweight],  [p(real 50) numberdraws(integer 200) imp(int 5) impnm(string) repnm(string) repwt(string) ci(int 95) nodofcorr]

        * q: quantile desired
        * numberdraws: number of replicate draws
        * imp: number of implicates
        * repnm: name of replicates, default is "mm"
        * repwt: name of replicate weight, default is "wt1b"
        * ci: desired confidence interval, default is 95%

        /***************************************/
        /* /\* set defaults if not invoked *\/ */
        /***************************************/


        if "`impnm'" == "" {
          local impnm = "rep"
        }

        if "`repnm'" == "" {
          local repnm = "mm"
        }

        if "`repwt'" == "" {
          local repwt = "wt1b" 
        }

        if "`weight'" == "" {
          di "WARNING: NO WEIGHTS INVOKED"
        }

        /**********************************************/
        /* /\* first generate imputation variance *\/ */
        /**********************************************/
        local depvar: word 1 of `varlist'

        /* keep just what you want */ o
        if "`if'" != "" { 
          keep `if'
        }

        /* /\* get the total number of degrees of freedom in the dataset *\/  */
        count
        local vcom = `r(N)'/5 - 2 

        /* generate the regression for each implicate */
        forv i = 1/`imp' { 

             qreg `depvar' [`weight'`exp'] if `impnm' == `i', q(`p') 

             /* get the point estimate */ 
               local cons`i' = _b[_cons]
        }

        /* now generate the mean constant */
        local meancons = (`cons1' +  `cons2'  + `cons3' + `cons4' + `cons5') / `imp'

        /* generate the imputation variance */
        local imputsum = 0 

        /* loop over all the implicates */
        forv i = 1/`imp' {

            local imputsum = `imputsum' + (`cons`i'' - `meancons')^2

        }

        /* store the imputation variance */ 
        local imputvar = `imputsum' / (`imp'-1)   /// imp-1 is the denominator for the variance

        /****************************************************/
        /* /\* generate the sampling variance of implicate #1 *\/  */
        /****************************************************/
        /* preserve the data */
        keep if `impnm' == 1 
        local bootsum = 0

        /* loop over all boostraps  */
        forv boot = 1/`numberdraws' {
                preserve

                        di "bootstrapping `boot'" 

                        qui {
                          
                                /* drop variables with missing numberdraws weights */ 
                                keep if `repnm'`boot' < 1000

                                /* expand each observation as many times as it was drawn in the boostrap */ 
                                expand `repnm'`boot'

                                /* just keep the variable you want */
                                keep `depvar' `repwt'`boot'

                                /* only invoke weights if it is called */ 
                                if "`weight'" != "" {
                                   local exp = "`repwt'`boot'"
                                }
                                
                                /* generate the variable you want */
                                qreg `depvar' [`weight'`exp'], q(`p') 

                                /* store the local variable */
                                local drawscons`boot' = _b[_cons]
                                local drawsum = `drawsum' + `drawscons`boot''

                        }


                restore
        }

        /* generate the mean of all the bootstraps */
        local numberdrawsmean = `drawsum'/`numberdraws'
        local imputsum = 0

        /* loop over all the repliccates */
        forv boot = 1/`numberdraws' {
                local imputsum = `imputsum' + (`drawscons`boot'' - `numberdrawsmean')^2
        }


        /* determine the within variance */
        local bootvar = `imputsum' / (`numberdraws' - 1)

        /* add the two */
        local totalvar = ((`imp'+1) / `imp') * `imputvar' + `bootvar' // note that the "between" variance REQUIRES multiplying by (m + 1) / m

        /********************************************/
        /* /\* generate post-estimation results *\/ */
        /********************************************/
        tempname mean variance

        /* set these up as matrices */
        mat `mean' = `meancons'
        matrix colnames `mean' = _cons
        mat rownames `mean' = `depvar' 

        mat `variance' = `totalvar'
        mat rownames `variance' = _cons 
        mat colnames `variance' = _cons

        matrix list `mean'
        matrix list `variance'

        /*************************************************/
        /* /\* generate the degrees of freedom correction *\/  */
        /*************************************************/
        *see: Barnard and Rubin, Biometrika, 2009, equation 3 for the full expression 

        /* recall that we obtained the total degrees of freedom in the complete data above, stored as vcom */
        /* gamma is the degrees of freedom if the sample were infinite */ 
        local gamma = (1 + `imp'^(-1)) * `imputvar'/`totalvar'

        /* now we combine this with the total degrees of freedom in hte complete data */ 
        local lambda = (`vcom' + 1)/(`vcom'+3) * (1-`gamma') 
        local quotient = `vcom' /(`imp'-1)*(`gamma'^(2)) 
        local degrees = (`lambda'^(-1) + `quotient')^(-1) * `vcom'

        /* if the DOF correction is turned off, just assume large sample */ 
        if "`dofcorr'" != "" {
          local degrees = 10000000000
        }

        /* make a total variance variable */ 
        ereturn post `mean' `variance', depname(`depvar') dof(`degrees') rlevel(`ci')
        ereturn display 
        ereturn list

end
